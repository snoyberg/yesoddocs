# Introduction

Every one of our Yesod applications requires an instance of the Yesod typeclass. So far, we've only seen the approot method, with the cryptic definition <code>approot _ = ""</code>. In this chapter, we'll explore the meaning of the approot method, along with many other methods in the Yesod typeclass.

The Yesod typeclass gives us a central place for defining settings for our application. Excluding the approot method, everything else has a default definition which is usually the right thing. But in order to build a powerful, customized application, you'll usually end up overriding at least a few of these methods.

# Rendering and Parsing URLs

We've already mentioned how Yesod is able to automatically render type-safe URLs into a textual URL that can be inserted into an HTML page. Let's say we have a route definition that looks like:

    mkYesod "MyApp" [$parseRoutes|
    /some/path SomePathR GET
    |]

If we place SomePathR into a hamlet template, how does Yesod render it? Yesod always tries to construct *absolute* URLs. This is especially useful once we start creating XML sitemaps and Atom feeds, or sending emails. But in order to construct an absolute URL, we need to get domain name of the application.

You might think to just get that information from the user's request, but we still need to deal with ports. And even if we get the port number from the request, are we using HTTP or HTTPS? And even if you know *that*, such an approach would break one of our RESTful principles: depending on how the user submitted a request would generate different URLs. For example, we would generate different URLs depending if the user connected to "example.com" or "www.example.com".

And finally, Yesod doesn't make any assumption about *where* you host your application. For example, I may have a mostly static site (http://static.example.com/), but I'd like to stick a Yesod-powered Wiki at /wiki/. There is no reliable way for an application to determine what subpath it is being hosted from. So instead of doing all of this guesswork, Yesod needs you to tell us the **application root**.

So using the wiki example, you would write your Yesod instance as:

    instance Yesod MyWiki where approot _ = "http://static.example.com/wiki"

Notice that there is no trailing slash there. Next, when Yesod wants to construct a URL for SomePathR, it determines that the relative path for SomePathR is "/some/path/", appends that to your approot and creates "http://static.example.com/wiki/some/path/".

This also explains our cryptic <code>approot _ = ""</code>: for our examples in the book, we're always serving from the root of the domain (in our case, localhost). By using an empty string, SomePathR renders to "/some/path/", which works just fine. In real life applications, however, you should use a real application root.

And by the way, the site template generated by the scaffolding tool automatically uses conditional compilation to switch between development and production builds, so you can easily test on one domain- like localhost- and serve from a different domain.

<p class="advanced">You may be wondering why we say <code>approot _ = ...</code> instead of <code>approot = ...</code>. The reason is a technicality of type classes in Haskell: without some argument to the approot function, we'd have no way of knowing which instance of Yesod to use for getting the application root.</p>

## Splitting and Joining

Let's look a little bit more closely at our example above. In our routes declaration, we said "/some/path" (sans trailing slash), while our generated URL includes a trailing slash ("/some/path/"). When we declare routes, all of the slashes are stripped out and we are left with a list of Strings, eg ["some", "path"]. We have a pair of methods in the Yesod typeclass the deals with how the URLs are actually displayed to users:

* joinPath takes the application root, a list of path pieces and a list of query string parameters, returning a fully rendered URL.

* splitPath takes a *relative* path, and either returns a new URL to redirect to, or a list of pieces. By relative, I mean everything after the application root. Redirection is used to ensure we have a single, canonical URL.

These two functions actually need to do a lot of work. There's percent encoding/decoding, query string generation, non-ASCII character handling, and generating canonical URLs. You can override these functions, but be warned that if they are not consistent, you can have problems. For example, if you write a joinPath the omits a trailing slash, and a splitPath that requires a trailing slash, every single time someone clicks on a link they'll get a 301 redirect to get to the correct URL.

The default implementation of these methods creates URLs that follow these rules:

* No double slashes. This also means it's impossible to get empty path pieces.

* If the last path piece has a period (.) in it, then there cannot be a trailing slash.

* Otherwise, there *must* be a trailing slash.

These rules may sound arbitrary, but they are useful for generally creating nice-looking URLs. The period rule makes it seem that filenames do not end with a trailing slash, while non-files do. Obviously, with dynamically generated content the divide between file and non-file can be arbitrary.

But let's say you need to create URLs without any trailing slashes, ever. You could try out the following:

~typeclass-noslash

We use some functions from the web-routes package, which handle a lot of the heavy lifting of UTF8 and percent encoding. Our joinPath function is fairly simple: it uses encodePathInfo to render a list of pieces and a query string to a relative URL, and then prepends the application root (plus a slash separator).

splitPath breaks our path into pieces using decodePathInfo, then *reconstructs* a URL using joinPath. If the new path matches the original path, then the user requested the canonical URL and everything is fine. Otherwise, we need to redirect to the newly constructed path.

# defaultLayout

Most websites like to apply some general template to all of their pages. defaultLayout is the recommended approach for this. While you could just as easily define your own function and call that instead, when you override defaultLayout all of the Yesod-generated pages (error pages, authentication pages) automatically get this style.

Overriding is very straight-forward: we use <code>widgetToPageContent</code> to convert a Widget to a title, head tags and body tags, and then use hamletToRepHtml to convert a Hamlet template into a RepHtml. We can even use widget functions like addCassius from within defaultLayout. A simple example should make this all clear:

~typeclass-layout

__FIXME: mention getMessage__

# Outline

* Custom errorHandler example
* Sessions (encryptKey- horizontal scaling, clientSessionDuration)
* Logging with onRequest
* Some special features for static files (addStaticContent, urlRenderOverride)
* Auth stuff (isAuthorized, isWriteRequest, authRoute)

In the basics chapter we showed some example Yesod applications and explained that the foundation datatype needed to be an instance of the Yesod typeclass. This typeclass is a central place to declare settings for your Yesod application. Besides approot, all of these settings are optional, but they 

<hr>

### getMessage

A common requirement in web applications is setting a message during one request and displaying it during another. For example, let's say you are logging into a site and type the wrong password. The application would like to show a message saying "invalid password" and allow you to type in your username/password again. There are basically two approaches to this:

1) In the handler that checks for a valid password, return a login form with the error message whenever an invalid password is submitted.

2) The handler that checks for a valid password redirects to the original login form when there is an invalid password.

At first glance option 1 sounds preferable, since it avoids an extra HTTP request. However, in general it's a good idea to avoid returning content from a POST request, since it can complicate back/forward button usage and make refreshing a page tricky. The problem with the second approach is that we need some way to tell the original login form page to display the error message.

Yesod provides a built in set of functions: getMessage and setMessage. We will cover these in more detail when discussing sessions, but for now it's enough to know that your defaultLayout should display the message returned by getMessage. Not only will this simplify your application code by just having to call getMessage once, but it will make interoperation with built-in Yesod features much better. A basic example would be:

    defaultLayout widget = do
        PageLayout title headTag bodyTag <- widgetToPageLayout widget
        mmsg <- getMessage
        hamletToRepHtml [$hamlet|
        !!!
        %html
            %head
                %title $title$
                ^headTag^
            %body
                $maybe mmsg msg
                    #message $msg$
                ^bodyTag^
        |]

# Summary

By using built-in Yesod constructs like defaultLayout and getMessage, you'll get a consistent look-and-feel throughout your site, including pages automatically generated by Yesod such as error pages and authentication.
