<?xml version="1.0" encoding="utf-8"?>
<chapter id="yesod-typeclass" status="Proofread">
    <title>Yesod Typeclass</title>
    <intro>
        <p id="i1">Every one of our Yesod applications requires an instance of the Yesod typeclass. So far, we've only seen the approot method, with the cryptic definition <code>approot _ = ""</code>, and defaultLayout. In this chapter, we'll explore the meaning of the approot method, along with many other methods in the Yesod typeclass.</p>
        <p id="i2">The Yesod typeclass gives us a central place for defining settings for our application. Excluding the approot method, everything else has a default definition which is usually the right thing. But in order to build a powerful, customized application, you'll usually end up overriding at least a few of these methods.</p>
    </intro>
    <section id="rendering-parsing-urls">
        <title>Rendering and Parsing URLs</title>
        <p id="rpu1">We've already mentioned how Yesod is able to automatically render type-safe URLs into a textual URL that can be inserted into an HTML page. Let's say we have a route definition that looks like:</p>

        <codeblock>mkYesod "MyApp" [$parseRoutes|
/some/path SomePathR GET
]</codeblock>

        <p id="rpu2">If we place SomePathR into a hamlet template, how does Yesod render it? Yesod always tries to construct <i>absolute</i> URLs. This is especially useful once we start creating XML sitemaps and Atom feeds, or sending emails. But in order to construct an absolute URL, we need to know the domain name of the application.</p>
        <p id="rpu3">You might think to just get that information from the user's request, but we still need to deal with ports. And even if we get the port number from the request, are we using HTTP or HTTPS? And even if you know <i>that</i>, such an approach would break one of our RESTful principles: depending on how the user submitted a request would generate different URLs. For example, we would generate different URLs depending if the user connected to "example.com" or "www.example.com".</p>
        <p id="rpu4">And finally, Yesod doesn't make any assumption about <i>where</i> you host your application. For example, I may have a mostly static site (http://static.example.com/), but I'd like to stick a Yesod-powered Wiki at /wiki/. There is no reliable way for an application to determine what subpath it is being hosted from. So instead of doing all of this guesswork, Yesod needs you to tell it the <term>application root</term>.</p>
        <p id="rpu5">So using the wiki example, you would write your Yesod instance as:</p>

        <codeblock>instance Yesod MyWiki where approot _ = "http://static.example.com/wiki"</codeblock>

        <p id="rpu6">Notice that there is no trailing slash there. Next, when Yesod wants to construct a URL for SomePathR, it determines that the relative path for SomePathR is "/some/path", appends that to your approot and creates "http://static.example.com/wiki/some/path".</p>

        <p id="rpu7">This also explains our cryptic <code>approot _ = ""</code>: for our examples in the book, we're always serving from the root of the domain (in our case, localhost). By using an empty string, SomePathR renders to "/some/path", which works just fine. In real life applications, however, you should use a real application root.</p>

        <p id="rpu8">And by the way, the site template generated by the scaffolding tool automatically uses conditional compilation to switch between development and production builds, so you can easily test on one domain- like localhost- and serve from a different domain.</p>

        <advanced>
            <p id="rpu9">You might be wondering: why does approot take that first argument if it is always ignored? There are two reasons:</p>
            <ul>
                <li>It is needed by Haskell's type system to determine which instance of Yesod to use for grabbing the typeclass.</li>
                <li>And actually, the first argument is <i>not</i> always ignored. For example, if you want to load the application root value from a configuration file, the most logical place to store that value is in the foundation datatype, and then for the approot function to grab the value from there.</li>
            </ul>
        </advanced>

        <section id="join-path">
            <title>joinPath</title>
            <p id="jp1">In order to convert a type-safe URL into a text value, Yesod uses two helper functions. The first is the <code>renderRoute</code> method of the <code>RenderRoute</code> typeclass. Every type-safe URL is an instance of this typeclass. <code>renderRoute</code> simply converts a value into a list of path pieces. For example, our <code>SomePathR</code> from above would be converted into ["some", "path"].</p>

            <advanced>
                <p id="jp2">Actually, renderRoute produces both the path pieces and a list of query-string parameters. The default instances of renderRoute always provide an empty list of query string parameters. However, it is possible to override this. One notable case is the static subsite, which puts a hash of the file contents in the query string for caching purposes.</p>
            </advanced>

            <p id="jp3">The other function is the <code>joinPath</code> method of the Yesod typeclass. This function takes the four arguments: the foundation value, the application root, a list of path segments and a list of query string parameters, and returns a textual URL. The default implementation does the "right thing": it separates the path pieces by forward slashes, prepends the application root and appends the query string.</p>

            <p id="jp4">If you are happy with default URL rendering, you should not need to modify it. However, if you want to modify URL rendering to do things like append a trailing slash, this would be the place to do it.</p>
        </section>

        <section id="clean-path">
            <title>cleanPath</title>
            <p id="cp1">The flip side to <code>joinPath</code> is <code>cleanPath</code>. Let's look at how it gets used in the dispatch process:</p>
            <ol>
                <li>The path info requested by the user is split into a series of path pieces.</li>
                <li>If any prefix of the path pieces matches a subsite, then dispatching is passed off to the subsite.</li>
                <li>Otherwise, we pass the path pieces to the cleanPath function.</li>
                <li>If cleanPath indicates a redirect (a Left response), then a 301 response is sent to the client. This is used to force canonical URLs (eg, remove extra slashes).</li>
                <li>Otherwise, we try to dispatch to our non-subsite routes using the response from cleanPath (a Right). If this works, we return a response. Otherwise, we return a 404.</li>
            </ol>
            <p id="cp2">This combination allows subsites to retain full control of how their URLs appear, yet allows master sites to have modified URLs. As a simple example, let's see how we could modify Yesod to always produce trailing slashes on URLs:</p>
            <snippet name="yesod-trailingslash"/>
            <p id="cp3">First, let's look at our joinPath implementation. This is copied almost verbatim from the default Yesod implementation, with one difference: when the initial pieces is not empty, we append an extra empty string to the end. When dealing with path pieces, an empty string will simply append another slash. So adding an extra empty string will force a trailing slash. The only time to do <i>not</i> want this trailing slash is when we are looking at the root of the application, because adding an extra slash will result in two slashes in a row.</p>
            <p id="cp4">cleanPath is a little bit trickier. First, we check for the empty path like before, and if so pass it through as-is. We use Right to indicate that a redirect is not necessary. The next clause is actually checking for two different possible URL issues:</p>
            <ul>
                <li>There is a double slash, which would show up as an empty string in the middle of our paths.</li>
                <li>There is a missing trailing slash, which would show up as the last piece not being an empty string.</li>
            </ul>
            <p id="cp5">Assuming neither of those conditions hold, then only the last piece is empty, and we should dispatch based on all but the last piece. However, if this is not the case, we want to redirect to a canonical URL. In this case, we strip out all empty pieces and do not bother appending a trailing slash, since joinPath will do that for us.</p>
        </section>
    </section>
    <section id="defaultLayout">
        <title>defaultLayout</title>
        <p id="dl1">Most websites like to apply some general template to all of their pages. defaultLayout is the recommended approach for this. While you could just as easily define your own function and call that instead, when you override defaultLayout all of the Yesod-generated pages (error pages, authentication pages) automatically get this style.</p>
        <p id="dl2">Overriding is very straight-forward: we use <code>widgetToPageContent</code> to convert a Widget to a title, head tags and body tags, and then use hamletToRepHtml to convert a Hamlet template into a RepHtml. We can even use widget functions like addCassius from within defaultLayout. A simple example should make this all clear:</p>
        <snippet name="typeclass-layout"/>

        <advanced>

            <p id="dl3">The three exclamation points (!!!) on a line by
                themselves is used to insert a doctype statement in Hamlet. By
                default, this will be the HTML 5 doctype line, ie
                <code>&lt;!DOCTYPE html&gt;</code>. You should make certain to
                only insert this once per output. In most use cases, the only
                place you will need it is in your defaultLayout function.</p>

        </advanced>

        <section id="getMessage">
            <title>getMessage</title>
            <p id="gm1">Even though we haven't covered sessions yet, I'd like to mention getMessage here. A common pattern in web development is needed to set a message in one handler and display it in another. For example, if a user POSTs a form, you may want to redirect him/her to another page along with a "Form submission complete" message.</p>
            <p id="gm2">To facilitate this, Yesod comes built in with a pair of functions: setMessage sets a message in the user session, and getMessage retrieves the message (and clears it, so it doesn't appear a second time). It's recommended that you put the result of getMessage into your defaultLayout. For example:</p>
            <snippet name="typeclass-getmessage"/>
            <p id="gm3">We'll cover getMessage/setMessage in more detail when we <link chapter="sessions">discuss sessions</link>.</p>
        </section>
    </section>
    <section id="custom-error-pages">
        <title>Custom error pages</title>
        <p id="cep1">One of the marks of a professional web site is a properly designed error page. Yesod gets you a long way there by automatically using your defaultLayout for displaying error pages. But sometimes, you'll want to go even further. For this, you'll want to override the errorHandler method:</p>
        <snippet name="typeclass-errorhandler"/>
        <p id="cep2">Here we specify a custom 404 error page. We can also use the defaultErrorHandler when we don't want to write a custom handler for each error type. Due to type constraints, we need to start off our methods with "fmap chooseRep", but otherwise you can write a typical handler function.</p>
        <p id="cep3">In fact, you could even use special responses like redirects:</p>
        <snippet name="typeclass-errorhandler-redirect"/>
        <note>Even though you <i>can</i> do this, I don't actually recommend such practices. A 404 should be a 404.</note>
    </section>
    <summary>
        <p id="s1">The Yesod typeclass has a number of overrideable methods that allow you to configure your application. Besides approot, they are all optional. By using built-in Yesod constructs like defaultLayout and getMessage, you'll get a consistent look-and-feel throughout your site, including pages automatically generated by Yesod such as error pages and authentication.</p>
        <p id="s2">We haven't covered all the methods in the Yesod typeclass in this chapter. Some of them relate to topics we have not yet covered (such as authentication), and will be discussed in those chapters. For a full listing of methods available, you should always consult the Haddock documentation.</p>
    </summary>
</chapter>
